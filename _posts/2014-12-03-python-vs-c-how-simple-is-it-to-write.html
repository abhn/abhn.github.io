---
layout: post
title: Python vs C - How simple is it to write a pair of communicating sockets?
tags:
- C
- socket
- python
---

<div dir="ltr" style="text-align: left;" trbidi="on">Lately I have been reading a lot of articles online written to compare Python to other languages. It is not a secret to anyone that the Python community is growing, and along with it, is the number of people who promote/recommend this language, of course.<br /><br />Let me not add up to the already large mass of those articles by boasting about Python's usability, speed and practicality, but rather, I will compare the two languages by writing a small socket client/server pair in each of those languages.<br /><br />But first, let me give you some of my personal opinions about both the languages since I know them well enough. C is very dear to me, not only because it was the first language I had ever learnt, but also because it runs most of the GNU, and GNU is well, very dear to me! C also happens to be my only second language of choice, after Python (although I know bits of Java, I prefer not to use it, not sure why, but I hate it). I have been programming in Python only from the last couple of months and I was really impressed. I solve HackerEarth and CodeChef problems as a pass time. Although I could do all of the problems I have done in C, doing them in Python took like 1/10th of the time (literally!) and 1/10th the typing effort. I would admit, C is much more fun to write than Python, simply because you 'feel' the code is yours, and I love to code C whenever I am free, will I use it in an environment where time is the priority? Probably not. Maybe when C is the only way out, but most of the time, I am better off writing it in Python.<br /><br />That being said, the popularity of C doesn't get any less, and it is going to stay that way as long as, maybe the Internet. Here's something I found.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html" target="_blank"><img alt="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html" border="0" src="http://3.bp.blogspot.com/-l2vEWUaIJRw/VHSs9LRv2XI/AAAAAAAAHtY/FCiYUKjLqGU/s1600/prolan.png" height="340" title="Click to follow link to source" width="640" /></a> </div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">You see the thing on top there? Yes, it is there for a reason. To make it short, C is powerful, very powerful. C gives you access to things you can not really imagine in other languages. On the other hand, Python is practical, flexible, and easy to learn. Web apps, sockets, Raspberry Pi, Arduino, Android or anything else you can imagine, there has to be a library made for it by someone, somewhere.</div><div class="separator" style="clear: both; text-align: left;"><br /></div><h3 class="separator" style="clear: both; text-align: left;">The code part.</h3><div class="separator" style="clear: both; text-align: left;">I am giving the client and server code in both the languages here as is. No explanation and stuff, because that's not the topic here. Note that all the source codes are tested running OK on Kali 1.0.6, gcc and all stock stuff, so it should be not much trouble to get it running. Windows guy, search for gcc directory and run it over the command prompt. It won't run from any IDE. </div><div class="separator" style="clear: both; text-align: left;"><br /></div><h4>Python</h4><div style="text-align: left;">Writing a pair of communicating TCP sockets require around 30 minutes along with the understanding part, if you have got some background in networking. Python does most of the stuff for you, and you just create a socket variable, supply host and port and that's it. Rest is left to your imagination (or not, I got too carried away!). Here comes the code:</div><div style="text-align: left;"></div><div style="text-align: left;"><b>client.py</b><br /><pre class="brush: cpp">import socket<br />s = socket.socket()<br />host = socket.gethostname()<br />port = 1356&nbsp;<br />s.connect((host, port))<br />shit = s.recv(1024)<br />print shit<br />s.close()<br /></pre></div><div style="text-align: left;"><br /></div><div style="text-align: left;"><b>server.py</b><br /><pre class="brush: python">s = socket.socket()<br />host = socket.gethostname()<br />s.bind((host, 1356))<br />s.listen(5)<br />while True:<br />&nbsp;&nbsp;&nbsp; c, addr = s.accept()<br />&nbsp; &nbsp; c.send("Message from server")<br />&nbsp;&nbsp;&nbsp; c.close()</pre></div>And that is it. Even if it looks lame (which it is), it is the maybe the simplest thing that qualifies to be called a server/client.<br /><br /><h4 style="text-align: left;">C</h4><div style="text-align: left;">Now lets write the same in C. This is around 4 times the size of Python code, and much of the stuff are done by hand (nothing new for C, I suppose). This code is the shortest I could cut it to, and just does one simple task. Sends the "Client talking loud!\n" message to server over port 1356 on localhost. The parameters can be edited as per convenience to suit any inter network testing, but that's the most this code will do. Nevertheless, this is a TCP client/server model.</div><div style="text-align: left;"><br /></div><div style="text-align: left;"><b>client.c</b><br /><pre class="brush: cpp">#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;string.h&gt;<br />#include &lt;sys/types.h&gt;<br />#include &lt;sys/socket.h&gt;<br />#include &lt;netinet/in.h&gt;<br />#include &lt;netdb.h&gt;<br />#include &lt;unistd.h&gt;<br /><br />int main(int argc, char **argv) {<br />    int sock, port, n;<br />    struct sockaddr_in serv_addr;<br />    struct hostent *server;<br />    char buffer[256];<br />    port = atoi("1356");<br />    sock = socket(AF_INET, SOCK_STREAM, 0);<br />    server = gethostbyname("127.0.0.1");<br />    bzero((char *)&amp;serv_addr, sizeof(serv_addr));<br />    serv_addr.sin_family = AF_INET;<br />    bcopy((char *)server-&gt;h_addr, (char *)&amp;serv_addr.sin_addr.s_addr, server-&gt;h_length);<br />    serv_addr.sin_port = htons(port);<br />    connect(sock, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));<br />    bzero(buffer, 256);<br />    strcpy(buffer, "Client talking loud!\n");<br />    write(sock, buffer, strlen(buffer));<br />    close(sock);<br />} </pre><br /><br /><b>server.c</b><br /><pre class="brush: cpp">#include &lt;stdio.h&gt; <br />#include &lt;strings.h&gt; <br />#include &lt;stdlib.h&gt; <br />#include &lt;sys/types.h&gt; <br />#include &lt;sys/socket.h&gt; <br />#include &lt;netinet/in.h&gt; <br /><br /><br />int main(int argc, char **argv) {<br /> int sock, nsock, port;<br /> socklen_t clilen;<br /> char buffer[256];<br /> struct sockaddr_in serv_addr, cli_addr;<br /> sock = socket(AF_INET, SOCK_STREAM, 0);<br /> bzero((char*)&amp;serv_addr, sizeof(serv_addr));<br /> port = atoi("1356");<br /> serv_addr.sin_family = AF_INET;<br /> serv_addr.sin_addr.s_addr = INADDR_ANY;<br /> serv_addr.sin_port = htons(port);<br /> bind(sock, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));<br /> listen(sock, 2);<br /> clilen = sizeof(cli_addr);<br /> nsock = accept(sock, (struct sockaddr *)&amp;cli_addr, &amp;clilen);<br /> bzero(buffer, 256);<br /> read(nsock, buffer, 255);<br /> printf("%s\n", buffer);<br /> close(sock);<br /> close(nsock);<br />}</pre>Here is the expected output:<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-82OK-zLd_cA/VH4E-XMscoI/AAAAAAAAHts/pYeKJB5Nf_4/s1600/Screenshot%2Bfrom%2B2014-12-03%2B00%3A02%3A38.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-82OK-zLd_cA/VH4E-XMscoI/AAAAAAAAHts/pYeKJB5Nf_4/s1600/Screenshot%2Bfrom%2B2014-12-03%2B00%3A02%3A38.png" height="433" width="640" /></a></div><br />Sorry, there is no commenting in the above code, and it really needs some explanation. I would've written them, but then, the code would have grown three folds (LOL)! It will need another nice article to explain all the stuff from that client.c and server.c code. I will conclude here. Thank you for reading :)<br /><br /><i>Update: If you happen to run any of the above code, make sure you run server first! </i></div><div style="text-align: left;"></div></div>
